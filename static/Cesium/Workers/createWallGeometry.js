define(["./when-208fe5b0","./Cartesian2-716c2715","./Transforms-f1816abc","./ComponentDatatype-549ec0d3","./Check-d18af7c4","./GeometryAttribute-0ee94cf1","./GeometryAttributes-b0b294d8","./IndexDatatype-d9b71b2b","./Math-3ba16bed","./VertexFormat-24041ad5","./WallGeometryLibrary-dd239953","./RuntimeError-7f634f5d","./WebGLConstants-76bb35d1","./arrayRemoveDuplicates-28d5a12e","./PolylinePipeline-fe86878e","./EllipsoidGeodesic-4bc5cec5","./EllipsoidRhumbLine-886cd793","./IntersectionTests-680c4e46","./Plane-f5dfabcd"],function(S,I,q,N,p,M,W,B,U,u,J,e,t,i,r,a,n,o,s){"use strict";var Y=new I.Cartesian3,Z=new I.Cartesian3,j=new I.Cartesian3,K=new I.Cartesian3,Q=new I.Cartesian3,X=new I.Cartesian3,$=new I.Cartesian3;function f(e){var t=(e=S.defaultValue(e,S.defaultValue.EMPTY_OBJECT)).positions,i=e.maximumHeights,r=e.minimumHeights;if(!S.defined(t))throw new p.DeveloperError("options.positions is required.");if(S.defined(i)&&i.length!==t.length)throw new p.DeveloperError("options.positions and options.maximumHeights must have the same length.");if(S.defined(r)&&r.length!==t.length)throw new p.DeveloperError("options.positions and options.minimumHeights must have the same length.");var a=S.defaultValue(e.vertexFormat,u.VertexFormat.DEFAULT),n=S.defaultValue(e.granularity,U.CesiumMath.RADIANS_PER_DEGREE),e=S.defaultValue(e.ellipsoid,I.Ellipsoid.WGS84);this._positions=t,this._minimumHeights=r,this._maximumHeights=i,this._vertexFormat=u.VertexFormat.clone(a),this._granularity=n,this._ellipsoid=I.Ellipsoid.clone(e),this._workerName="createWallGeometry";t=1+t.length*I.Cartesian3.packedLength+2;S.defined(r)&&(t+=r.length),S.defined(i)&&(t+=i.length),this.packedLength=t+I.Ellipsoid.packedLength+u.VertexFormat.packedLength+1}f.pack=function(e,t,i){if(!S.defined(e))throw new p.DeveloperError("value is required");if(!S.defined(t))throw new p.DeveloperError("array is required");var r;i=S.defaultValue(i,0);var a=e._positions,n=a.length;for(t[i++]=n,r=0;r<n;++r,i+=I.Cartesian3.packedLength)I.Cartesian3.pack(a[r],t,i);var o=e._minimumHeights,n=S.defined(o)?o.length:0;if(t[i++]=n,S.defined(o))for(r=0;r<n;++r)t[i++]=o[r];var s=e._maximumHeights;if(n=S.defined(s)?s.length:0,t[i++]=n,S.defined(s))for(r=0;r<n;++r)t[i++]=s[r];return I.Ellipsoid.pack(e._ellipsoid,t,i),i+=I.Ellipsoid.packedLength,u.VertexFormat.pack(e._vertexFormat,t,i),t[i+=u.VertexFormat.packedLength]=e._granularity,t};var c=I.Ellipsoid.clone(I.Ellipsoid.UNIT_SPHERE),h=new u.VertexFormat,g={positions:void 0,minimumHeights:void 0,maximumHeights:void 0,ellipsoid:c,vertexFormat:h,granularity:void 0};return f.unpack=function(e,t,i){if(!S.defined(e))throw new p.DeveloperError("array is required");t=S.defaultValue(t,0);for(var r,a,n=e[t++],o=new Array(n),s=0;s<n;++s,t+=I.Cartesian3.packedLength)o[s]=I.Cartesian3.unpack(e,t);if(0<(n=e[t++]))for(r=new Array(n),s=0;s<n;++s)r[s]=e[t++];if(0<(n=e[t++]))for(a=new Array(n),s=0;s<n;++s)a[s]=e[t++];var m=I.Ellipsoid.unpack(e,t,c);t+=I.Ellipsoid.packedLength;var l=u.VertexFormat.unpack(e,t,h),d=e[t+=u.VertexFormat.packedLength];return S.defined(i)?(i._positions=o,i._minimumHeights=r,i._maximumHeights=a,i._ellipsoid=I.Ellipsoid.clone(m,i._ellipsoid),i._vertexFormat=u.VertexFormat.clone(l,i._vertexFormat),i._granularity=d,i):(g.positions=o,g.minimumHeights=r,g.maximumHeights=a,g.granularity=d,new f(g))},f.fromConstantHeights=function(e){var t=(e=S.defaultValue(e,S.defaultValue.EMPTY_OBJECT)).positions;if(!S.defined(t))throw new p.DeveloperError("options.positions is required.");var i=e.minimumHeight,r=e.maximumHeight,a=S.defined(i),n=S.defined(r);if(a||n)for(var o=t.length,s=a?new Array(o):void 0,m=n?new Array(o):void 0,l=0;l<o;++l)a&&(s[l]=i),n&&(m[l]=r);return new f({positions:t,maximumHeights:m,minimumHeights:s,ellipsoid:e.ellipsoid,vertexFormat:e.vertexFormat})},f.createGeometry=function(e){var t=e._positions,i=e._minimumHeights,r=e._maximumHeights,a=e._vertexFormat,n=e._granularity,o=e._ellipsoid,r=J.WallGeometryLibrary.computePositions(o,t,r,i,n,!0);if(S.defined(r)){for(var s=r.bottomPositions,m=r.topPositions,i=r.numCorners,l=m.length,n=2*l,d=a.position?new Float64Array(n):void 0,p=a.normal?new Float32Array(n):void 0,u=a.tangent?new Float32Array(n):void 0,f=a.bitangent?new Float32Array(n):void 0,c=a.st?new Float32Array(n/3*2):void 0,h=0,g=0,y=0,v=0,C=0,w=$,b=X,x=Q,E=!0,A=0,_=1/((l/=3)-i-1),F=0;F<l;++F){var D,L=3*F,H=I.Cartesian3.fromArray(m,L,Y),k=I.Cartesian3.fromArray(s,L,Z);a.position&&(d[h++]=k.x,d[h++]=k.y,d[h++]=k.z,d[h++]=H.x,d[h++]=H.y,d[h++]=H.z),a.st&&(c[C++]=A,c[C++]=0,c[C++]=A,c[C++]=1),(a.normal||a.tangent||a.bitangent)&&(D=I.Cartesian3.clone(I.Cartesian3.ZERO,K),k=I.Cartesian3.subtract(H,o.geodeticSurfaceNormal(H,Z),Z),F+1<l&&(D=I.Cartesian3.fromArray(m,3+L,K)),E&&(L=I.Cartesian3.subtract(D,H,j),k=I.Cartesian3.subtract(k,H,Y),w=I.Cartesian3.normalize(I.Cartesian3.cross(k,L,w),w),E=!1),I.Cartesian3.equalsEpsilon(H,D,U.CesiumMath.EPSILON10)?E=!0:(A+=_,a.tangent&&(b=I.Cartesian3.normalize(I.Cartesian3.subtract(D,H,b),b)),a.bitangent&&(x=I.Cartesian3.normalize(I.Cartesian3.cross(w,b,x),x))),a.normal&&(p[g++]=w.x,p[g++]=w.y,p[g++]=w.z,p[g++]=w.x,p[g++]=w.y,p[g++]=w.z),a.tangent&&(u[v++]=b.x,u[v++]=b.y,u[v++]=b.z,u[v++]=b.x,u[v++]=b.y,u[v++]=b.z),a.bitangent&&(f[y++]=x.x,f[y++]=x.y,f[y++]=x.z,f[y++]=x.x,f[y++]=x.y,f[y++]=x.z))}r=new W.GeometryAttributes;a.position&&(r.position=new M.GeometryAttribute({componentDatatype:N.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:d})),a.normal&&(r.normal=new M.GeometryAttribute({componentDatatype:N.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:p})),a.tangent&&(r.tangent=new M.GeometryAttribute({componentDatatype:N.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:u})),a.bitangent&&(r.bitangent=new M.GeometryAttribute({componentDatatype:N.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:f})),a.st&&(r.st=new M.GeometryAttribute({componentDatatype:N.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:c}));var V=n/3;n-=6*(i+1);var G=B.IndexDatatype.createTypedArray(V,n),P=0;for(F=0;F<V-2;F+=2){var T=F,z=F+2,O=I.Cartesian3.fromArray(d,3*T,Y),R=I.Cartesian3.fromArray(d,3*z,Z);I.Cartesian3.equalsEpsilon(O,R,U.CesiumMath.EPSILON10)||(O=F+1,R=F+3,G[P++]=O,G[P++]=T,G[P++]=R,G[P++]=R,G[P++]=T,G[P++]=z)}return new M.Geometry({attributes:r,indices:G,primitiveType:M.PrimitiveType.TRIANGLES,boundingSphere:new q.BoundingSphere.fromVertices(d)})}},function(e,t){return(e=S.defined(t)?f.unpack(e,t):e)._ellipsoid=I.Ellipsoid.clone(e._ellipsoid),f.createGeometry(e)}});
//# sourceMappingURL=createWallGeometry.js.map
